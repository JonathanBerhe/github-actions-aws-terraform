docker run --rm -it -v $HOME/professional/learning/aws_cli_docker/ignored/aws_credentials_terraform:/root/.aws -v $HOME/professional/learning/aws_cli_docker/ignored/shared:/shared -v $HOME/professional/learning/aws_cli_docker/ignored/key-pair:/key-pair -v $HOME/professional/learning/github-actions-aws-terraform:/github-actions-aws-terraform harishkannarao/awscli:latest /bin/bash

cd /github-actions-aws-terraform/

____________________________________________________________________

# Set AWS environment variables for login

export AWS_ACCESS_KEY_ID='<aws_account_key_id>'
export AWS_SECRET_ACCESS_KEY='<aws_account_secret_key>'
export AWS_DEFAULT_REGION='eu-west-2'
export AWS_DEFAULT_OUTPUT='json'

# Test aws cli login

aws configure list
aws sts get-caller-identity 

export DOCKER_AWS_ACCOUNT_ID="$AWS_ACCESS_KEY_ID"
export DOCKER_AWS_REGION='eu-west-2'
export ENVIRONMENT='development'
export APPLICATION_NAME='docker-http-app'

aws ecr get-login --registry-ids $DOCKER_AWS_ACCOUNT_ID --region $DOCKER_AWS_REGION --no-include-email

$(aws ecr get-login --registry-ids $DOCKER_AWS_ACCOUNT_ID --region $DOCKER_AWS_REGION --no-include-email)

export REPOSITORY_URI=$DOCKER_AWS_ACCOUNT_ID.dkr.ecr.$DOCKER_AWS_REGION.amazonaws.com/$APPLICATION_NAME/$ENVIRONMENT
export GIT_TAG=$(git rev-parse --verify HEAD)

docker build --pull -t $REPOSITORY_URI:$GIT_TAG -f ignored/Dockerfile ignored
docker push $REPOSITORY_URI:$GIT_TAG

docker tag $REPOSITORY_URI:$GIT_TAG $REPOSITORY_URI:$ENVIRONMENT
docker push $REPOSITORY_URI:$ENVIRONMENT

# docker run --rm -it --name java-wiremock-server -p "8080:80" "$REPOSITORY_URI:$GIT_TAG"

aws ecs update-service --cluster $APPLICATION_NAME-$ENVIRONMENT-ecs-cluster --service $APPLICATION_NAME-$ENVIRONMENT --force-new-deployment

-------

Cloudwatch Logs Insights: 
Choose log group as: docker-http-app-development

Application Logs:

fields @timestamp, @message
| filter @message not like /ACCESS_LOG/
| display @message

Access Logs:

fields @timestamp, @message
| filter @message like /ACCESS_LOG/
| display @message

fields @timestamp, @message
| filter @message like /ACCESS_LOG/
| parse '* * * * * * * * * *' as date, time, message, resTime, byte, status, ip, reqId, method, url
| filter url not like /\/health-check/
| stats count(@message) by bin(60s)

fields @timestamp, @message
| filter @message like /ACCESS_LOG/
| parse '* * * * * * * * * *' as date, time, message, resTime, byte, status, ip, reqId, method, url
| filter url not like /\/health-check/
| stats count(@message)

fields @timestamp, @message
| filter @message like /ACCESS_LOG/
| parse '* * * * * * * * * *' as date, time, message, resTime, byte, status, ip, reqId, method, url
| filter url not like /\/health-check/
| stats count(@message) by status

fields @timestamp, @message
| filter @message like /ACCESS_LOG/
| parse '* * * * * * * * * *' as date, time, message, resTime, byte, status, ip, reqId, method, url
| filter url not like /\/health-check/
| stats count(@message) as statusCount by status
| sort statusCount desc

fields @timestamp, @message
| filter @message like /ACCESS_LOG/
| parse '* * * * * * * * * *' as date, time, message, resTime, byte, status, ip, reqId, method, url
| filter url not like /\/health-check/
| filter status like /[4-5]../

fields @timestamp, @message
| filter @message like /ACCESS_LOG/
| parse '* * * * * * * * * *' as date, time, message, resTime, byte, status, ip, reqId, method, url
| filter url not like /\/health-check/
| filter status like /[2-3]../

fields @timestamp, @message
| filter @message like /ACCESS_LOG/
| parse '* * * * * * * * * *' as date, time, message, resTime, byte, status, ip, reqId, method, url
| filter url not like /\/health-check/
| stats avg(resTime) as avg, pct(resTime, 95) as pct95 by bin(60s)

-------

aws logs filter-log-events --log-group-name docker-http-app-development | jq -r '.events[].message'

aws logs filter-log-events --filter-pattern '"ACCESS_LOG" - "/health-check"' --log-group-name docker-http-app-development | jq -r '.events[].message'

aws logs filter-log-events --filter-pattern '- "ACCESS_LOG" "INFO"' --log-group-name docker-http-app-development | jq -r '.events[].message'

aws logs filter-log-events --filter-pattern '"ACCESS_LOG"' --log-group-name docker-http-app-development --start-time 1586603083000 --end-time 1586603652000 | jq -r '.events[].message'

aws logs filter-log-events --filter-pattern '- "ACCESS_LOG"' --log-group-name docker-http-app-development --start-time 1586603083000 --end-time 1586603652000 | jq -r '.events[].message'

[date, time, message=ACCESS_LOG, resTime, byte, status, ip, reqId, method, url]
[date, time, message=ACCESS_LOG, resTime, byte, status, ip, reqId, method=*GET*, url!=*health-check*]
[date, time, message=ACCESS_LOG, resTime, byte, status>=400&&status<=599, ip, reqId, method, url]

aws logs filter-log-events --filter-pattern '[date, time, message=ACCESS_LOG, resTime, byte, status, ip, reqId, method=*GET*, url!=*health-check*]' --log-group-name docker-http-app-development | jq -r '.events[].message'

-------

Terraform graphs using GraphViz(https://www.graphviz.org)

terraform graph -type=refresh environments/$ENV_NAME | dot -Tpng > ignored/refresh_graph.png

terraform graph -type=plan environments/$ENV_NAME | dot -Tpng > ignored/plan_graph.png

terraform graph -type=apply environments/$ENV_NAME | dot -Tpng > ignored/apply_graph.png

terraform graph -type=plan-destroy environments/$ENV_NAME | dot -Tpng > ignored/plan_destroy_graph.png

-------------

taskArns=$(aws ecs list-tasks --cluster "docker-http-app-development-ecs-cluster" --service-name "docker-http-app-development" | jq -r '.taskArns[]' | grep -E '\S' | tr '\n' ' ')

aws ecs describe-tasks --cluster "docker-http-app-development-ecs-cluster" --tasks $taskArns | jq -r '.tasks[].containers[].networkInterfaces[].privateIpv4Address'

aws rds describe-db-instances --db-instance-identifier development-database | jq -r '.DBInstances[].Endpoint.Address'

aws ec2 describe-instances --filters "Name=tag:Type,Values=development-bastion" | jq -r '.Reservations[].Instances[].PublicIpAddress' | grep -E '\S' | grep -v 'null'

chmod 400 ignored/ssh-key-development.pem

ssh -A -L 8180:10.0.10.35:80 -L 10006:10.0.10.35:10006 -L 5432:development-database.cqntfjo5fd4k.eu-west-2.rds.amazonaws.com:5432 -i ignored/ssh-key-development.pem ec2-user@35.178.66.242

ssh ec2-user@10.0.10.35

curl -s 'http://localhost:8180' | jq

Visual VM: service:jmx:rmi:///jndi/rmi://localhost:10006/jmxrmi

---------------

/* the task definition for the db migration */
data "template_file" "db_migrate_task" {
  template = "${file("${path.module}/tasks/db_migrate_task_definition.json")}"

  vars {
    image           = "${aws_ecr_repository.openjobs_app.repository_url}"
    secret_key_base = var.secret_key_base
    database_url    = "postgresql://${var.database_username}:${var.database_password}@${var.database_endpoint}:5432/${var.database_name}?encoding=utf8&pool=40"
    log_group       = "openjobs"
  }
}

resource "aws_ecs_task_definition" "db_migrate" {
  family                   = "${var.environment}_db_migrate"
  container_definitions    = "${data.template_file.db_migrate_task.rendered}"
  requires_compatibilities = ["FARGATE"]
  network_mode             = "awsvpc"
  cpu                      = "256"
  memory                   = "512"
  execution_role_arn       = "${aws_iam_role.ecs_execution_role.arn}"
  task_role_arn            = "${aws_iam_role.ecs_execution_role.arn}"
}


repository_url     = "$DOCKER_AWS_ACCOUNT_ID.dkr.ecr.$DOCKER_AWS_REGION.amazonaws.com/openjobs/$ENVIRONMENT"
region             = "$DOCKER_AWS_REGION"
cluster_name       = "$ENVIRONMENT-ecs-cluster"
subnet_ids          = "<private_subnet_id_1>,<private_subnet_id_2>,<private_subnet_id_3>"
security_group_ids = "<vpc_default_security_group_id>,<postgres_db_access_security_group_id>"


aws ecs run-task --launch-type FARGATE --cluster $cluster_name --task-definition $ENVIRONMENT_db_migrate --network-configuration "awsvpcConfiguration={subnets=[$subnet_ids],securityGroups=[$security_group_ids]}"
