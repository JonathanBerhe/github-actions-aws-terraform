cd $HOME/professional/learning

git clone git@github.com:harishkannarao/aws_cli_docker.git

cd aws_cli_docker

docker build --pull -t harishkannarao/awscli:latest -f Dockerfile .

export AWS_ACCESS_KEY_ID_TERRAFORM='<aws_account_key_id>'
export AWS_SECRET_ACCESS_KEY_TERRAFORM='<aws_account_secret_key>'

docker run --rm -it \
  -e "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID_TERRAFORM" \
  -e "AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY_TERRAFORM" \
  -e "AWS_DEFAULT_REGION=eu-west-2" \
  -e "AWS_DEFAULT_OUTPUT=json" \
  -v $HOME/professional/learning/github-actions-aws-terraform:/github-actions-aws-terraform \
  harishkannarao/awscli:latest /bin/bash

cd /github-actions-aws-terraform/

aws configure list

aws sts get-caller-identity 

____________________________________________________________________

Change region and availability zone

Preview the changes

grep -rn 'eu-west-2' .

Replace the region

find . -type f -print0 | xargs -0 sed -i '' 's/eu-west-2/us-east-1/g'

----------------------
# Set AWS environment variables for login

export AWS_ACCESS_KEY_ID='<aws_account_key_id>'
export AWS_SECRET_ACCESS_KEY='<aws_account_secret_key>'
export AWS_DEFAULT_REGION='eu-west-2'
export AWS_DEFAULT_OUTPUT='json'

# Test aws cli login

aws configure list
aws sts get-caller-identity 

export DOCKER_AWS_ACCOUNT_ID='<aws_account_id>'
export DOCKER_AWS_REGION='eu-west-2'
export ENVIRONMENT='development'
export APPLICATION_NAME='docker-http-app'

aws ecr get-login --registry-ids $DOCKER_AWS_ACCOUNT_ID --region $DOCKER_AWS_REGION --no-include-email

$(aws ecr get-login --registry-ids $DOCKER_AWS_ACCOUNT_ID --region $DOCKER_AWS_REGION --no-include-email)

export REPOSITORY_URI=$DOCKER_AWS_ACCOUNT_ID.dkr.ecr.$DOCKER_AWS_REGION.amazonaws.com/$APPLICATION_NAME/$ENVIRONMENT

export GIT_TAG=$(git rev-parse --verify HEAD)

docker build --pull -t $REPOSITORY_URI:$GIT_TAG -f ignored/Dockerfile ignored
docker push $REPOSITORY_URI:$GIT_TAG

docker tag $REPOSITORY_URI:$GIT_TAG $REPOSITORY_URI:$ENVIRONMENT
docker push $REPOSITORY_URI:$ENVIRONMENT

# docker run --rm -it --name java-wiremock-server -p "8080:80" "$REPOSITORY_URI:$GIT_TAG"

aws ecs update-service --cluster $APPLICATION_NAME-$ENVIRONMENT-ecs-cluster --service $APPLICATION_NAME-$ENVIRONMENT --force-new-deployment

-------

aws ecr get-login --registry-ids $DOCKER_AWS_ACCOUNT_ID --region $DOCKER_AWS_REGION --no-include-email

$(aws ecr get-login --registry-ids $DOCKER_AWS_ACCOUNT_ID --region $DOCKER_AWS_REGION --no-include-email)

export REPOSITORY_URI=$DOCKER_AWS_ACCOUNT_ID.dkr.ecr.$DOCKER_AWS_REGION.amazonaws.com/$APPLICATION_NAME/$ENVIRONMENT

export ROLL_BACK_TAG='roll_back_version_tag'

docker pull $REPOSITORY_URI:$ROLL_BACK_TAG

docker tag $REPOSITORY_URI:$ROLL_BACK_TAG $REPOSITORY_URI:$ENVIRONMENT

docker push $REPOSITORY_URI:$ENVIRONMENT

aws ecs update-service --cluster $APPLICATION_NAME-$ENVIRONMENT-ecs-cluster --service $APPLICATION_NAME-$ENVIRONMENT --force-new-deployment

---------

Cloudwatch Logs Insights: 
Choose log group as: docker-http-app-development

Application Logs:

fields @timestamp, @message
| filter @message not like /ACCESS_LOG/
| sort @timestamp desc
| display @message

Access Logs:

fields @timestamp, @message
| filter @message like /ACCESS_LOG/
| sort @timestamp desc
| display @message

fields @timestamp, @message
| filter @message like /ACCESS_LOG/
| parse '* * * * * * * * * *' as date, time, message, resTime, byte, status, ip, reqId, method, url
| filter url not like /\/health-check/
| stats count(@message) by bin(60s)

fields @timestamp, @message
| filter @message like /ACCESS_LOG/
| parse '* * * * * * * * * *' as date, time, message, resTime, byte, status, ip, reqId, method, url
| filter url not like /\/health-check/
| stats count(@message)

fields @timestamp, @message
| filter @message like /ACCESS_LOG/
| parse '* * * * * * * * * *' as date, time, message, resTime, byte, status, ip, reqId, method, url
| filter url not like /\/health-check/
| stats count(@message) by status

fields @timestamp, @message
| filter @message like /ACCESS_LOG/
| parse '* * * * * * * * * *' as date, time, message, resTime, byte, status, ip, reqId, method, url
| filter url not like /\/health-check/
| stats count(@message) as statusCount by status
| sort statusCount desc

fields @timestamp, @message
| filter @message like /ACCESS_LOG/
| parse '* * * * * * * * * *' as date, time, message, resTime, byte, status, ip, reqId, method, url
| filter url not like /\/health-check/
| filter status like /[4-5]../

fields @timestamp, @message
| filter @message like /ACCESS_LOG/
| parse '* * * * * * * * * *' as date, time, message, resTime, byte, status, ip, reqId, method, url
| filter url not like /\/health-check/
| filter status like /[2-3]../

fields @timestamp, @message
| filter @message like /ACCESS_LOG/
| parse '* * * * * * * * * *' as date, time, message, resTime, byte, status, ip, reqId, method, url
| filter url not like /\/health-check/
| filter (resTime>=6000)

fields @timestamp, @message
| filter @message like /ACCESS_LOG/
| parse '* * * * * * * * * *' as date, time, message, resTime, byte, status, ip, reqId, method, url
| filter url not like /\/health-check/
| filter status in [400,401,404]

fields @timestamp, @message
| filter @message like /ACCESS_LOG/
| parse '* * * * * * * * * *' as date, time, message, resTime, byte, status, ip, reqId, method, url
| filter url not like /\/health-check/
| filter status not in [200,204]

fields @timestamp, @message
| filter @message like /ACCESS_LOG/
| parse '* * * * * * * * * *' as date, time, message, resTime, byte, status, ip, reqId, method, url
| filter url not like /\/health-check/
| stats avg(resTime) as avg, pct(resTime, 95) as pct95 by bin(60s)

-------

aws logs filter-log-events --log-group-name docker-http-app-development | jq -r '.events[].message'

aws logs filter-log-events --filter-pattern '"ACCESS_LOG" - "/health-check"' --log-group-name docker-http-app-development | jq -r '.events[].message'

aws logs filter-log-events --filter-pattern '- "ACCESS_LOG" "INFO"' --log-group-name docker-http-app-development | jq -r '.events[].message'

aws logs filter-log-events --filter-pattern '"ACCESS_LOG"' --log-group-name docker-http-app-development --start-time 1586603083000 --end-time 1586603652000 | jq -r '.events[].message'

aws logs filter-log-events --filter-pattern '- "ACCESS_LOG"' --log-group-name docker-http-app-development --start-time 1586603083000 --end-time 1586603652000 | jq -r '.events[].message'

[date, time, message=ACCESS_LOG, resTime, byte, status, ip, reqId, method, url]
[date, time, message=ACCESS_LOG, resTime, byte, status, ip, reqId, method=*GET*, url!=*health-check*]
[date, time, message=ACCESS_LOG, resTime, byte, status>=400&&status<=599, ip, reqId, method, url]

aws logs filter-log-events --filter-pattern '[date, time, message=ACCESS_LOG, resTime, byte, status, ip, reqId, method=*GET*, url!=*health-check*]' --log-group-name docker-http-app-development | jq -r '.events[].message'

-------

Terraform graphs using GraphViz(https://www.graphviz.org)

terraform graph -type=refresh environments/$ENV_NAME | dot -Tpng > ignored/refresh_graph.png

terraform graph -type=plan environments/$ENV_NAME | dot -Tpng > ignored/plan_graph.png

terraform graph -type=apply environments/$ENV_NAME | dot -Tpng > ignored/apply_graph.png

terraform graph -type=plan-destroy environments/$ENV_NAME | dot -Tpng > ignored/plan_destroy_graph.png

-------------

aws rds describe-db-instances --db-instance-identifier development-database | jq -r '.DBInstances[].Endpoint.Address'

taskArns=$(aws ecs list-tasks --cluster "docker-http-app-development-ecs-cluster" --service-name "docker-http-app-development" | jq -r '.taskArns[]' | grep -E '\S' | tr '\n' ' ')

aws ecs describe-tasks --cluster "docker-http-app-development-ecs-cluster" --tasks $taskArns | jq -r '.tasks[].containers[].networkInterfaces[].privateIpv4Address'

aws ec2 describe-instances --filters "Name=tag:Type,Values=development-bastion" | jq -r '.Reservations[].Instances[].PublicIpAddress' | grep -E '\S' | grep -v 'null'

chmod 400 ignored/ssh-key-development.pem

ssh -o StrictHostKeyChecking=no -i ignored/ssh-key-development.pem ubuntu@3.8.158.100

ssh -o StrictHostKeyChecking=no -L 5432:development-database.cqntfjo5fd4k.eu-west-2.rds.amazonaws.com:5432 -i ignored/ssh-key-development.pem ubuntu@35.178.181.176

ssh -o StrictHostKeyChecking=no -L 8180:10.0.20.183:80 -L 10006:10.0.20.183:10006 -i ignored/ssh-key-development.pem ubuntu@3.8.233.106

Visual VM: service:jmx:rmi:///jndi/rmi://localhost:10006/jmxrmi

export PGPASSWORD=development_db_password && psql -h localhost -p 5432 -d development_db -U development_db_user

--------

chmod 400 ignored/ssh-key-development.pem

ssh-add ignored/ssh-key-development.pem

ssh-add -L

ssh -o StrictHostKeyChecking=no -A -i ignored/ssh-key-development.pem ubuntu@35.178.23.17

ssh-add -L

ssh -o StrictHostKeyChecking=no root@10.0.30.51

ssh-add -D

ssh-add -D

top

curl -s 'http://localhost/health-check' | jq

curl -s 'https://docker-http-app-development.harishkannarao.com/health-check' | jq

curl --insecure -s 'https://docker-http-app-development-alb-271831461.eu-west-2.elb.amazonaws.com/health-check' | jq

---------------

ssh-keygen -t rsa -f ignored/mynew_key

chmod 400 ignored/mynew_key

aws ec2-instance-connect send-ssh-public-key --region eu-west-2 --instance-id i-08fea708eb9c53fa0 --availability-zone eu-west-2b --instance-os-user ubuntu --ssh-public-key file://ignored/mynew_key.pub

ssh -i mynew_key ubuntu@3.8.181.133

---------------

/* the task definition for the db migration */
data "template_file" "db_migrate_task" {
  template = "${file("${path.module}/tasks/db_migrate_task_definition.json")}"

  vars {
    image           = "${aws_ecr_repository.openjobs_app.repository_url}"
    secret_key_base = var.secret_key_base
    database_url    = "postgresql://${var.database_username}:${var.database_password}@${var.database_endpoint}:5432/${var.database_name}?encoding=utf8&pool=40"
    log_group       = "openjobs"
  }
}

resource "aws_ecs_task_definition" "db_migrate" {
  family                   = "${var.environment}_db_migrate"
  container_definitions    = "${data.template_file.db_migrate_task.rendered}"
  requires_compatibilities = ["FARGATE"]
  network_mode             = "awsvpc"
  cpu                      = "256"
  memory                   = "512"
  execution_role_arn       = "${aws_iam_role.ecs_execution_role.arn}"
  task_role_arn            = "${aws_iam_role.ecs_execution_role.arn}"
}


repository_url     = "$DOCKER_AWS_ACCOUNT_ID.dkr.ecr.$DOCKER_AWS_REGION.amazonaws.com/openjobs/$ENVIRONMENT"
region             = "$DOCKER_AWS_REGION"
cluster_name       = "$ENVIRONMENT-ecs-cluster"
subnet_ids          = "<private_subnet_id_1>,<private_subnet_id_2>,<private_subnet_id_3>"
security_group_ids = "<vpc_default_security_group_id>,<postgres_db_access_security_group_id>"


aws ecs run-task --launch-type FARGATE --cluster $cluster_name --task-definition $ENVIRONMENT_db_migrate --network-configuration "awsvpcConfiguration={subnets=[$subnet_ids],securityGroups=[$security_group_ids]}"
